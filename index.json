[{"categories":null,"content":"Overview Problem: Design a news feed system. What’s a news feed? “News feed is the constantly updating list of stories in the middle of your homepage. News feed includes status updates, photos, videos, links, app activity and likes from people, pages, and groups that you follow on Facebook.” ","date":"2021-08-17","objectID":"/posts/fb_newsfeed/:1:0","tags":null,"title":"Design FB News Feed","uri":"/posts/fb_newsfeed/"},{"categories":null,"content":"Step 1: Understand the problem and scope Make sure to ask clarifying questions to gauge the scope of the problem which you have to design around. Some sample questions: Is it a mobile app? Web app? both? What are the important features? Is the news feed sorted? Reverse chronological or other? How many friends can a user have? What is the traffic volume? Does the feed contain media? Or just text? ","date":"2021-08-17","objectID":"/posts/fb_newsfeed/:2:0","tags":null,"title":"Design FB News Feed","uri":"/posts/fb_newsfeed/"},{"categories":null,"content":"Step 2: Propose high-level design Two parts: feed publishing and news feed building. Feed publishing: user publishes post, data is written to cache and database. Posts are populated to friend’s news feeds. Newsfeed building: We’re assuming the news feed is built by aggregating friends' posts in reverse chronological order. ","date":"2021-08-17","objectID":"/posts/fb_newsfeed/:3:0","tags":null,"title":"Design FB News Feed","uri":"/posts/fb_newsfeed/"},{"categories":null,"content":"Newsfeed APIs Feed publishing API HTTP Post to publish with the content and an auth_token. e.g. POST /v1/me/feed Newsfeed retrieval API The API to get the news feed. Supply auth token. e.g. GET /v1/me/feed ","date":"2021-08-17","objectID":"/posts/fb_newsfeed/:3:1","tags":null,"title":"Design FB News Feed","uri":"/posts/fb_newsfeed/"},{"categories":null,"content":"Feed publishing flow The main pieces to the flow are the users, load balancer, web servers, post service, fanout service, and notification service. The users will view and make posts through the API. The load balancer distributes traffic evenly to the web servers. The web servers redirect traffic to different internal services. Post service is responsible for persisting posts in the db and cache. The fanout service’s job is to push new content to friends' news feeds. Newsfeed data is stored in the cache for fast retrieval. The notification service informs friends that new content is available and it sends out push notifications. ","date":"2021-08-17","objectID":"/posts/fb_newsfeed/:3:2","tags":null,"title":"Design FB News Feed","uri":"/posts/fb_newsfeed/"},{"categories":null,"content":"Step 3: Dig in to the design Feed Publishing Dive The role of the web server is to communicate with clients, and also enforce authentication and rate-limiting. Users need a valid auth token to make posts, and the number of posts a user can make within a certain period will be limited to prevent abuse. Fanout Fanout is the process of distributing a post to friends. There are two different approaches to fanout: Fanout on write: News feed is pre-computed during write time. A new post is delivered to a friends' cache right after it’s published. Pros: News feed is generated in real time and can be pushed immediately Fetching news is fast because its pre-computed Cons: If a user has a lot of friends, fetching the friend list and generating news feeds for all of them are slow and time consuming. This is known as a hotkey problem. For inactive users, pre-computing news feeds wastes compute. Fanout on read: The newsfeed is generated during read time, on demand. When a user loads their home page, thats when recent posts are pulled. Pros: For inactive users this is a better approach because it won’t waste compute. No hotkey problem because data isn’t pushed to friends Cons: Fetching the news feed is slow. We can adopt a hybrid approach depending on the amount of friends a user has. This is similar to how Twitter handles their regular users vs. celebrities. We can use a push model for most users, but then use a pull model for celebrities. Consistent hashing is a useful technique to get around the hotkey (or hotspot) problem as it helps distribute requests evenly. The fanout service flow is like this: Fetch friend IDs from the graph db. Graph db’s are suited for managing friend relationship and friend recommendations. Get friends info from the user cache. Then filter out friends based on user settings, like if you mute someone you shouldn’t see their posts. Send friends list and new post ID to the message queue. Fanout workers fetch data from the queue and store news feed data in the news feed cache. Store post_id, and user_id in the cache. ","date":"2021-08-17","objectID":"/posts/fb_newsfeed/:3:3","tags":null,"title":"Design FB News Feed","uri":"/posts/fb_newsfeed/"},{"categories":["System_Design"],"content":"Ch 6: Partitioning Note: These are my notes from reading chapter 6 of Designing Data Intensive applications. For large datasets, or very high query throughput, we need to break the data up into partitions, also known as sharding. In effect, each partition is a small database of its own. ","date":"2021-08-10","objectID":"/posts/ddia_ch6/:0:0","tags":["DDIA"],"title":"DDIA Notes Ch.6: Partitioning","uri":"/posts/ddia_ch6/"},{"categories":["System_Design"],"content":"Partitioning and Replication Basically, you can use both partitioning and replication together to have high availability. You can have copies of each partition stored on multiple nodes. And a node can store more than one partition. ","date":"2021-08-10","objectID":"/posts/ddia_ch6/:1:0","tags":["DDIA"],"title":"DDIA Notes Ch.6: Partitioning","uri":"/posts/ddia_ch6/"},{"categories":["System_Design"],"content":"Partitioning of Key-Value data The goal of partitioning is to evenly spread out the work among your nodes. Something to look out for is hot spots, areas where lots of data is clustered for some reason or other, and you end up getting bottlenecked. ","date":"2021-08-10","objectID":"/posts/ddia_ch6/:2:0","tags":["DDIA"],"title":"DDIA Notes Ch.6: Partitioning","uri":"/posts/ddia_ch6/"},{"categories":["System_Design"],"content":"Partitioning by Key Range An approach to partitioning is by separating your data into ranges. For example if you have it indexed by letter keys, you could have groups like A through F, and G through O. Then, when you need to find something it becomes easy as long as your keys are in sorted order. ","date":"2021-08-10","objectID":"/posts/ddia_ch6/:2:1","tags":["DDIA"],"title":"DDIA Notes Ch.6: Partitioning","uri":"/posts/ddia_ch6/"},{"categories":["System_Design"],"content":"Partitioning by Hash of Key Certain access patterns of the key-range partitioning method can lead to hot spots. For ex: if the key is a timestamp, then the partitions correspond to ranges of time, this can lead to hot spots if all the writes happen at the same time. Because of this risk of skew and hot spots, many distributed datastores use a hash function to determine the partition for a given key. A good hash function takes skewed data and makes it uniformly distributed. Once you have a good hash function for keys, you can assign each partition a range of hashes rather than a range of keys. ","date":"2021-08-10","objectID":"/posts/ddia_ch6/:2:2","tags":["DDIA"],"title":"DDIA Notes Ch.6: Partitioning","uri":"/posts/ddia_ch6/"},{"categories":["System_Design"],"content":"Skewed Workloads and Relieving Hot Spots Sometimes having a good hash function isn’t enough, because for example a hot source could produce hot spots with the same hash. A simple technique is to add a random number to the beginning or end of the key. Just a two digit decimal random number would split the writes to the key evenly across 100 different keys. ","date":"2021-08-10","objectID":"/posts/ddia_ch6/:2:3","tags":["DDIA"],"title":"DDIA Notes Ch.6: Partitioning","uri":"/posts/ddia_ch6/"},{"categories":["System_Design"],"content":"Partitioning and Secondary Index Partitioning becomes more complex if secondary indexes are involved. What is a secondary index? A secondary index usually doesn’t identify a record uniquely, but rather is a way of searching for occurrences of a particular value. Find all actions by user 123, find all cars whose color is red, etc. Problem: They don’t map nearly to partitions. solution: Document-based partitioning and term-based partitioning ","date":"2021-08-10","objectID":"/posts/ddia_ch6/:2:4","tags":["DDIA"],"title":"DDIA Notes Ch.6: Partitioning","uri":"/posts/ddia_ch6/"},{"categories":["System_Design"],"content":"Rebalancing Partitions As your db grows and changes, data and requests need to be moved from one node to another. The process of moving load around is called rebalancing. ","date":"2021-08-10","objectID":"/posts/ddia_ch6/:3:0","tags":["DDIA"],"title":"DDIA Notes Ch.6: Partitioning","uri":"/posts/ddia_ch6/"},{"categories":["System_Design"],"content":"Strategies for Rebalancing Hash mod N: Bad. Too costly, and moves data around unnecessarily Fixed number of partitions: Pretty good, create many more partitions than there are nodes. The only thing that changes is the assignment of partitions to nodes. Dynamic partitioning: key range-partitioned databases create partitions dynamically. When a partition grows to exceed a configured size, it is split into two partitions so half the data ends up on each side. An advantage is that the number of partitions adapts to the total data volume. But while the dataset is small, all writes have to be processed by a single node while the other nodes sit idle. Have a fixed number of partitions per node. ","date":"2021-08-10","objectID":"/posts/ddia_ch6/:3:1","tags":["DDIA"],"title":"DDIA Notes Ch.6: Partitioning","uri":"/posts/ddia_ch6/"},{"categories":["System_Design"],"content":"Request Routing This is an instance of a more general problem called service discovery. Few different approaches: Allow clients to contact any node Send all requests from clients to a routing tier first Require that clients be aware of the partitioning and the assignment of partitions to nodes. ","date":"2021-08-10","objectID":"/posts/ddia_ch6/:4:0","tags":["DDIA"],"title":"DDIA Notes Ch.6: Partitioning","uri":"/posts/ddia_ch6/"},{"categories":["System_Design"],"content":"Summary Partitioning is necessary when you have a ton of data that storing and processing it on a single machine is not possible. Goal of partitioning: Spread the data and query load evenly across multiple machines and avoid hot spots (nodes with high load). Two main approaches to partitioning: Key range partitioning Hash partitioning A secondary index also needs to be partitioned. Two approaches to secondary index partitioning: Document partitioned indexes (local indexes): secondary indexes are stored in the same partition as the primary key and value. Write can be to a single partition, but a read is heavy and requires a scatter/gather across all partitions. Term-partitioned indexes (global indexes): secondary indexes are partitioned separately. An entry in the secondary index may include records from all partitions of the primary key. Writes are heavier, but read can be from a single partition. ","date":"2021-08-10","objectID":"/posts/ddia_ch6/:5:0","tags":["DDIA"],"title":"DDIA Notes Ch.6: Partitioning","uri":"/posts/ddia_ch6/"},{"categories":["Algo"],"content":"Invert a Binary Tree ","date":"2021-08-10","objectID":"/posts/invert_binary_tree/:0:0","tags":["trees"],"title":"Invert binary tree","uri":"/posts/invert_binary_tree/"},{"categories":["Algo"],"content":"Overview \u0026 Problem Space Problem: Write a function that takes in a Binary Tree and inverts it. The function should swap every left node in the tree for its corresponding right node. Each BinaryTree node has an integer value, a left child node and a right child node. Children nodes can either be BinaryTree nodes themselves or None/null. ","date":"2021-08-10","objectID":"/posts/invert_binary_tree/:1:0","tags":["trees"],"title":"Invert binary tree","uri":"/posts/invert_binary_tree/"},{"categories":["Algo"],"content":"Theory I like this problem because its a classic and the solution is actually really clean. So “inverting a binary tree” really means swap each child node. I think the recursive solution is the easiest to think about, so I’ll go over that first, and then talk about the iterative solution. Recursive: For the recursive solution, I like creating a helper method to handle the swaps. In the helper, first we check the base case if the node is none, and then we do the swaps. I love doing swaps in Python because they’re so simple and don’t require a temp variable: After the swap, we call the function on the left child and the right child. Finally return the node! Then call this function in the original invertBinaryTree function and we’re done. Iterative: So this solution follows an approach similar to BFS, where we use a queue to hold the nodes we have to iterate through. We first create a queue with a single element, the root node. Then while the length of the queue is not zero, we pop off the first element of the queue, swap the left and right children, and then append that node’s left and right child nodes ","date":"2021-08-10","objectID":"/posts/invert_binary_tree/:2:0","tags":["trees"],"title":"Invert binary tree","uri":"/posts/invert_binary_tree/"},{"categories":["Algo"],"content":"Implementation ","date":"2021-08-10","objectID":"/posts/invert_binary_tree/:3:0","tags":["trees"],"title":"Invert binary tree","uri":"/posts/invert_binary_tree/"},{"categories":["Algo"],"content":"Recursive # O(n) time | O(log(n)) space def invertBinaryTree(tree): return invertBinaryTreeHelper(tree) def invertBinaryTreeHelper(node): if node is None: return node.left, node.right = node.right, node.left invertBinaryTreeHelper(node.left) invertBinaryTreeHelper(node.right) return node ","date":"2021-08-10","objectID":"/posts/invert_binary_tree/:3:1","tags":["trees"],"title":"Invert binary tree","uri":"/posts/invert_binary_tree/"},{"categories":["Algo"],"content":"Iterative # O(n) time | O(n) space def invertBinaryTree(tree): queue = [tree] while len(queue): current = queue.pop(0) if current is None: continue swapLeftAndRight(current) queue.append(current.left) queue.append(current.right) return tree def swapLeftAndRight(tree): tree.left, tree.right = tree.right, tree.left ","date":"2021-08-10","objectID":"/posts/invert_binary_tree/:3:2","tags":["trees"],"title":"Invert binary tree","uri":"/posts/invert_binary_tree/"},{"categories":null,"content":"About Me Hello! My name is Christian. ","date":"2021-08-09","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"This is my second post I have no idea what I am doing :) ","date":"2021-08-05","objectID":"/posts/second-post/:0:0","tags":null,"title":"Example post","uri":"/posts/second-post/"},{"categories":null,"content":"This is a section Blah blah blah ","date":"2021-08-05","objectID":"/posts/second-post/:1:0","tags":null,"title":"Example post","uri":"/posts/second-post/"},{"categories":null,"content":"Third Section Will this index? def hello(): print(\"Hello world!\") ","date":"2021-08-05","objectID":"/posts/second-post/:2:0","tags":null,"title":"Example post","uri":"/posts/second-post/"},{"categories":null,"content":"CORGI SECTION!!!! This is a corgi! I hope. ","date":"2021-08-05","objectID":"/posts/second-post/:3:0","tags":null,"title":"Example post","uri":"/posts/second-post/"},{"categories":null,"content":"Smaller section This is a smaller section. ","date":"2021-08-05","objectID":"/posts/second-post/:3:1","tags":null,"title":"Example post","uri":"/posts/second-post/"},{"categories":null,"content":"Medium Section Yuuuup. ","date":"2021-08-05","objectID":"/posts/second-post/:4:0","tags":null,"title":"Example post","uri":"/posts/second-post/"},{"categories":null,"content":"Youtube Embedding This is embedded with Hugo shortcode! ","date":"2021-08-05","objectID":"/posts/second-post/:5:0","tags":null,"title":"Example post","uri":"/posts/second-post/"},{"categories":null,"content":"Tweet Embedding Hugo 0.24 Released: Big archetype update + @Netlify _redirects etc. file supporthttps://t.co/X94FmYDEZJ #gohugo #golang @spf13 @bepsays — GoHugo.io (@GoHugoIO) June 21, 2017 ","date":"2021-08-05","objectID":"/posts/second-post/:6:0","tags":null,"title":"Example post","uri":"/posts/second-post/"},{"categories":null,"content":"Markdown Table test Syntax Description Header Title Paragraph Text ","date":"2021-08-05","objectID":"/posts/second-post/:6:1","tags":null,"title":"Example post","uri":"/posts/second-post/"},{"categories":null,"content":"Tips This is a tip A tip banner Or This is a note A note banner ","date":"2021-08-05","objectID":"/posts/second-post/:7:0","tags":null,"title":"Example post","uri":"/posts/second-post/"}]